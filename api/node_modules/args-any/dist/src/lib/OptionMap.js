"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionMap = void 0;
const string_converter_1 = require("string-converter");
const types_1 = require("../types");
const _1 = require(".");
const parse_1 = require("./parse");
const mapHelper_1 = require("./mapHelper");
/**
 * Map of `Option`
 */
class OptionMap extends types_1.ReadonlyMap {
    constructor(args, settings) {
        super(parse_1.parse(args, settings));
        this.args = _1.argContainer(args, this);
        this.settings = settings;
    }
    /**
     * Filter a list of items based on options defined in the map
     * @param items The items to filter
     * @returns The items matching options in the map
     */
    filter(...items) {
        // allow this alias for now
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const map = this;
        return items.filter(x => this.matches.call(map, x));
    }
    /**
     * Check if an option exists in the map
     * @param key key of the option to check
     * @returns `true` if the option exists, otherwise `false`
     */
    has(key) {
        return super.has(parse_1.prefixless(key, this.settings));
    }
    /**
     * Creates a `Partial<T>` from the `OptionMap` with the keys and values defined in the map
     */
    asPartial() {
        return mapHelper_1.toObject(this);
    }
    /**
     * Get option by key
     * @param key The option to fetch
     * @returns `Option` for the specified `key`
     */
    get(key) {
        return super.get(parse_1.prefixless(key, this.settings));
    }
    /** @ignore */
    matches(item) {
        return [...this.keys()].reduce((acc, curr) => {
            if (acc === false)
                return false;
            const itemValue = item[curr];
            const option = this.get(curr);
            if (option === undefined)
                return false;
            const optionValue = string_converter_1.convert(option.value);
            switch (option.operator) {
                case types_1.Operator.Ne:
                    return itemValue !== optionValue;
                case types_1.Operator.Ge:
                    return (optionValue && itemValue >= optionValue) || false;
                case types_1.Operator.Gt:
                    return (optionValue && itemValue > optionValue) || false;
                case types_1.Operator.Le:
                    return (optionValue && itemValue <= optionValue) || false;
                case types_1.Operator.Lt:
                    return (optionValue && itemValue < optionValue) || false;
                default:
                    return itemValue === optionValue;
            }
        }, true);
    }
}
exports.OptionMap = OptionMap;
//# sourceMappingURL=OptionMap.js.map